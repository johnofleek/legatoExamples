#include "legato.h"
#include "interfaces.h"	// manages auto generated code header files

#include "lsm6ds3.h"

// so we can release it later
static le_timer_Ref_t timerRef;


// mqtt settings
static const char* brokerUrl = "eu.airvantage.net";
static int32_t portNumber = 1883;
static int32_t keepAlive = (1*60);	 // see paho docs
static int32_t QoS = 0;
static const char* password = "JT_PI_001";


// an example of an IPC linked callback
// is called by autogenerated code when the mqtt app indicates a state change
static bool mqttConnected = false;

void mqttSessionState_cbh
(
	bool isConnected,
    int32_t connectErrorCode,
    int32_t subErrorCode,
    void* contextPtr
)
{
	mqttConnected = isConnected;
	if(isConnected)
	{
		LE_INFO("mqtt connected");
	}
	else
	{
		LE_INFO("mqtt disconnected: err:%d subErr:%d",connectErrorCode, subErrorCode );
	}
}



static int count = 12;
// This callack handler is called at the preset timer rate until the timer's stopped
 void timerPeriodicEvent_cbh(le_timer_Ref_t timerRef)
 {
	 le_mdc_ProfileRef_t profileRef = le_mdc_GetProfile( LE_MDC_DEFAULT_PROFILE );
	 le_mdc_ConState_t mdcState;
	 float AX, AY, AZ, temperature;
	 char jsonPayload[2048];
	 int32_t jsonErrCode;


	 // read the sensor values
	 temperature =  34.4;
	 LE_INFO("temperature=%f", temperature  );

	 AX = 12.3;
	 AY = 13.2;
	 AZ =0.9;

	 LE_INFO("AX=%f AY=%f AZ=%f", AX , AY , AZ );


	 // try to send the data to AVMS
	 le_mdc_GetSessionState(profileRef, &mdcState);	// get WAN connected info

	 if(mdcState == LE_MDC_DISCONNECTED)			// check that we have WAN
	 {
		 LE_INFO("requesting WAN connect" );
		 le_data_Request();
	 }
	 else if(!mqttConnected)						// check that mqttService is up
	 {
		 LE_INFO("requesting mqtt connect" );
		 mqtt_Connect (password);
	 }
	 else
	 {
		 // send the data to AVMS every so often
		 count++;
		 if(count > 12)
		 {
			 count = 0;
			 sprintf(jsonPayload,
					 "{"
					 "\"sensor.temperature\":%f,"
					 "\"sensor.AX\":%f,"
					 "\"sensor.AY\":%f,"
					 "\"sensor.AZ\":%f"
					 "}"
					 , temperature,
					 AX,
					 AY,
					 AZ
					 );
			 mqtt_SendJson(jsonPayload, &jsonErrCode);
		 }
	 }
}


// This sets up the timerPeriodicEvent_cbh
void timerPeriodicEvent_init(int period)
{
	le_clk_Time_t repeatInterval;
	repeatInterval.sec = period;
	repeatInterval.usec = 0;

    timerRef = le_timer_Create ("mainLoopTimer");
	le_timer_SetHandler ( timerRef, timerPeriodicEvent_cbh);
	le_timer_SetInterval( timerRef, repeatInterval);
	le_timer_SetRepeat( timerRef, 0 )	;	// 0 is forever
	le_timer_Start( timerRef);
}

// this application exit code
void appCleanup(void)
{						// Noticed that mqtt mqttSessionState_cbh occur with !isConnected even when mqtt is still connected
	mqtt_Disconnect();	// close any open connection - if we don't service is broken next time we use it

	LE_INFO("Requested mqttDemo disconnect");
}

// this function is called when this application is stopped with "app stop mqttDemo1"
static void sig_appTermination_cbh(int sigNum)
{
	appCleanup();
}

static void atexit_cbh(void)
{
	appCleanup();
}



// This is called first - a bit like main() but watch out main was called before this
// be aware that by default the set up of the comms with external apps runs before this
// this will not run until the external stuff is ready
// you can change this behaviour by setting up the requires: api: to [manual-start]
// if you do this you manually start the interface(s) in this code somewhere
COMPONENT_INIT
{
    LE_INFO("Hello, world. mqtt demo");

    // register callback handler to called when this app terminates due to SIGTERM program termination
    le_sig_Block(SIGTERM);
    le_sig_SetEventHandler(SIGTERM, sig_appTermination_cbh);

    /* from the manual
     Functions registered using atexit() (and on_exit(3)) are not called
     if a process terminates abnormally because of the delivery of a
     signal. */
    atexit(atexit_cbh);

    // because I asked for manual-start in the .cdef file
    // I need to manually connect to the external app / services
    le_data_ConnectService();
    LE_INFO("le_data is connected to this app");

    mqtt_ConnectService();
    LE_INFO("mqtt service is connected to this app");

    // an experiment to see if we can close mqtt if has been left connected
    if(mqtt_GetConnectionState())
    {
    	appCleanup();
    }
    // set up the mqtt service
    mqtt_AddSessionStateHandler
    (
    	mqttSessionState_cbh,
        NULL
    );

    mqtt_Config
    (
    	brokerUrl,
		portNumber,
		keepAlive,
		QoS
    );





    timerPeriodicEvent_init(10);
}
